<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:sws="http://www.springframework.org/schema/web-services"
    xmlns:oxm="http://www.springframework.org/schema/oxm" 
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:util="http://www.springframework.org/schema/util"

    xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/web-services 
        http://www.springframework.org/schema/web-services/web-services.xsd
        http://www.springframework.org/schema/oxm 
        http://www.springframework.org/schema/oxm/spring-oxm.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd">

    <!-- 
        This file is an example about how someone should write code in order to send and
        receive data from the Web Services.
    -->
   
    <!-- Searches for beans in packages (instead of XML configuration we can use in this way annotations like @Service, @Component, etc, etc)  --> 
    <context:component-scan base-package="de.spring.webservices"/>

    <!--
        Three ways of using a marshallers/unmarshallers.
        
        1. No declarar nada en el XML y dejar que Spring lo haga internamente todo por nosotros.
        Esto equivale a esta configuracion en XML
        
        <oxm:jaxb2-marshaller id="marshaller" context-path="de.spring.webservices"/>
        El context-path Spring supongo que lo rellena automáticamente en base al component-scan declarado arriba.
        
        2. Especificando el context-path para ser escaneado por Spring usando anotaciones. Esto
        se hace de este modo:
        
        <oxm:jaxb2-marshaller id="marshaller" context-path="de.spring.webservices.auto"/>
        Esto es lo mismo que haría Spring si no declaramos nada en el XML pero así tenemos opción de
        de especificar un context-path en concreto.
        
        3. Especificando la implementación concreta del marshaller.
        Con esta opción además puedo usar packagesToScan, contest-path si no recuerdo mal tenía problemas
        cuando había dos ObjectFactory con el mismo package. Uno está en globalxsds y otro en este proyecto.
        De todos modos, probablemente habría que usar un package distinto para lo que hay
     	en globalxsds (quizás incluso basado en el namespace del xsd) y así podría evitar esta configuración. 
     -->
	<bean id="marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
    	<!--
    		maven-jaxb2-plugin for WSDL DOES generate again the objects in web-services-spring-jaxb2-globalxsds :(
    		So we MAY NOT scan everything because there is more than one class representing
    		the same XML element. :(
    		
    		We scan the objects generated in this package.
    	-->
    	<property name="packagesToScan" value="de.spring.webservices.client.auto"/>
  	</bean>
     
   
    <!-- Required in order to use SOAP 1.2
         id="messageFactory" is not a random choice, if you use another name it will not work
         (Spring will end up loading SOAP 1.1)
    -->
    <bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory">
        <property name="soapVersion">
            <util:constant static-field="org.springframework.ws.soap.SoapVersion.SOAP_12" />
        </property>
    </bean> 
    

    <!-- 
        ¿Este validador funciona teniendo inheritance en el xsd? (inheritances es una cosa especial 
        del JAXB2 que estoy usando para generar las clases desde el xsd)
        Parece que el unmarshal (que supongo que se hace con el JAXB2 que está en el classpath
        debido al tipo de Endpoint que estoy usando, que por cierto no sé cual JAXB2 está cogiendo realmente) 
        funciona, así que supongo el validador tambien :/
        Lo que realmente tampoco sé es si hay alguna relación entre los validadores y JAXB2 :/
    -->
    <bean id="payloadValidatingInterceptor" 
        class="org.springframework.ws.client.support.interceptor.PayloadValidatingInterceptor">
        <property name="schemas">
            <list>
                <!--
                	ALWAYS FIRST THE XSD FILES TO BE IMPORTED!!!!!  O.o
                	OTHERWISE THE import IN examples.xsd WILL BE SOLVED BY MEANS OF DOWNLOADING THE
                	EXTERNAL parent.xsd (USING THE URL LINKED BY THE IMPORT STATEMENT IN examples.xsd)
                		 
        			IF YOU DON'T DO THIS, PayloadValidatingInterceptor WILL TRY TO CONNECT TO THE
        			EXTERNAL SERVER WHERE parent.xsd IS LOCATED AND IT WILL FAIL IF BECAUSE SOME
        			REASON YOU DON'T HAVE IN THAT VERY MOMENT NETWORK CONNECTION. SO, DON'T MESS WITH THIS
        			CONFIGURATION.
                 -->
                 <value>classpath:schemas/parent.xsd</value>
                    
                 <value>classpath:schemas/examples.xsd</value>
            </list>
        </property>
        <property name="validateRequest" value="true"/>
        <property name="validateResponse" value="true"/>
    </bean>
    
    <!-- 
		Los errores de validacion se devuelven así:
		
		<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope">
		   <env:Header/>
		   <env:Body>
		      <env:Fault>
		         <env:Code>
		            <env:Value>env:Sender</env:Value>
		         </env:Code>
		         <env:Reason>
		            <env:Text xml:lang="en">Validation error</env:Text>
		         </env:Reason>
		         <env:Detail>
		            <spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws">cvc-maxLength-valid: El valor 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' con la longitud = '91' no es de faceta válida con respecto a maxLength '30' para el tipo 'limitedString'.</spring-ws:ValidationError>
		            <spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws">cvc-type.3.1.3: El valor 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' del elemento 'exam:data' no es válido.</spring-ws:ValidationError>
		         </env:Detail>
		      </env:Fault>
		   </env:Body>
		</env:Envelope>
		
		El manejador de errores de validación es implementado por AbstractValidatingInterceptor (PayloadValidatingInterceptor)
		luego si quisiéramos loguear los mensaje de error de validación de algún modo especial tendríamos que crear nuestro propio PayloadValidatingInterceptor :(		
	 -->
    
    <!-- Enables us to log custom Fault remote messages. No loguea mensajes de error de validación :( -->
    <bean id="customFaultMessageResolver" class="de.spring.webservices.client.CustomFaultMessageResolver">
  		<property name="unmarshaller" ref="marshaller"/>
  	</bean>
  	
    <!-- 
    WebServiceTemplate using these strategies by default (see WebServiceTemplate.properties file)
    
    org.springframework.ws.client.core.FaultMessageResolver=org.springframework.ws.soap.client.core.SoapFaultMessageResolver
	org.springframework.ws.WebServiceMessageFactory=org.springframework.ws.soap.saaj.SaajSoapMessageFactory
	org.springframework.ws.transport.WebServiceMessageSender=org.springframework.ws.transport.http.HttpUrlConnectionMessageSender
    
     -->

    <bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
        <constructor-arg ref="messageFactory"/>
        <property name="marshaller" ref="marshaller" />
        <property name="unmarshaller" ref="marshaller" />

        <!-- For local deployments change to http://localhost:8080/web-services-spring-jaxb2-server/spring-ws/example -->
        <property name="defaultUri" value="http://localhost:8080/web-services-spring-cxf-server/spring-ws/example"/>

        <property name="interceptors">
            <list>
                <ref bean="payloadValidatingInterceptor" />
            </list>
        </property>
        
        <property name="faultMessageResolver" ref="customFaultMessageResolver" />
    </bean>
    
    <!--
    Using @Service and @Autowired
    We could use just XML configuration, or XML confirguration and @Autowired or as I am doing now @Service and @Autowired.
    <bean id="exampleClientService" class="de.spring.webservices.client.ExampleClientService">
        
        @Autowired works even using XML configuration as long as you use context:component-scan
        <property name="webServiceTemplate" ref="webServiceTemplate"/>
    </bean>
    -->
    
</beans>
